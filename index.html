<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading...</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let squares = [];            // quadrati correnti
    let originalSquares = [];    // posizioni originali da data.json
    let accelData = { x: 0, y: 0, z: 0 };
    let simulateGravity = false; // modalità gravità simulata (barra spazio)
    let restoring = false;       // modalità ritorno all'origine
    const accelThreshold = 15;   // soglia accelerazione per iniziare movimento
    let movementActive = false;  // flag per attivare movimento dopo la prima soglia

    // --- Disegno continuo dei quadrati ---
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const sq of squares) {
        ctx.fillStyle = sq.color;
        ctx.fillRect(sq.x, sq.y, sq.size, sq.size);
      }

      requestAnimationFrame(draw);
    }

    // --- Aggiorna posizione dei quadrati ---
    function updateSquares() {
      let gx = 0, gy = 0, gz = 0;

      // Movimento solo se accelerazione supera soglia o se la flag è attiva
      if (!movementActive) {
        if (Math.abs(accelData.x) > accelThreshold || Math.abs(accelData.y) > accelThreshold) {
          movementActive = true; // attiva movimento permanente
        }
      }

      if (movementActive) {
        gx = accelData.x;
        gy = accelData.y;
        gz = accelData.z || 0;
      }

      // Se stiamo simulando gravità da tastiera
      if (simulateGravity) {
        gz = 9.8 * 4; // simulazione di 1g amplificato
        movementActive = true; // attiva il movimento anche da tastiera
      }

      for (let i = 0; i < squares.length; i++) {
        const sq = squares[i];
        const ref = originalSquares[i]; // riferimento posizione originale

        if (restoring) {
          // ritorno graduale alla posizione originale
          sq.x += (ref.x - sq.x) * 0.08;
          sq.y += (ref.y - sq.y) * 0.08;
        } else {
          // movimento libero o gravitazionale
          sq.x += gx;
          sq.y += gy + gz;
        }

        // mantieni i quadrati dentro i bordi del canvas
        sq.x = Math.max(0, Math.min(canvas.width - sq.size, sq.x));
        sq.y = Math.max(0, Math.min(canvas.height - sq.size, sq.y));
      }

      requestAnimationFrame(updateSquares);
    }

    // --- Lettura accelerometro ---
    function handleMotion(event) {
      const acc = event.accelerationIncludingGravity;
      accelData.x = acc.x || 0;
      accelData.y = acc.y || 0;
      accelData.z = acc.z || 0;
    }

    // --- Gestione barra spaziatrice ---
    function handleKey(event) {
      if (event.code === "Space") {
        if (!simulateGravity && !restoring) {
          simulateGravity = true;
          restoring = false;
        } else {
          simulateGravity = false;
          restoring = true;
          setTimeout(() => restoring = false, 2000);
        }
      }
    }

    // --- Caricamento dati esterni ---
    async function loadData() {
      try {
        const response = await fetch("data.json");
        const data = await response.json();

        document.title = data.pageTitle;

        // salva copia originale e copia modificabile
        originalSquares = JSON.parse(JSON.stringify(data.squares));
        squares = JSON.parse(JSON.stringify(data.squares));

        window.addEventListener("devicemotion", handleMotion);
        window.addEventListener("keydown", handleKey);

        draw();
        updateSquares();

        console.log("Premi la barra spaziatrice per simulare gravità o ricomporre l'opera.");
      } catch (err) {
        console.error("Errore caricamento dati:", err);
      }
    }

    window.onload = loadData;

    // --- Adatta il canvas alla finestra ---
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
